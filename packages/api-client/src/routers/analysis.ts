import { router, protectedProcedure, managerProcedure } from '../trpc'
import { prisma, IntegrationType } from '@nexflow/database'
import { GitHubRepoAnalyzer, type GitHubRepoAnalysis } from '@nexflow/integrations'
import { AutonomousAnalyzer, BottleneckDetector, PredictionEngine } from '@nexflow/ai'

export const analysisRouter = router({
  // Trigger full autonomous analysis of all connected GitHub repos
  runAutonomousAnalysis: protectedProcedure.mutation(async ({ ctx }) => {
    // Check if GitHub is connected
    const githubIntegration = await prisma.integration.findUnique({
      where: {
        organizationId_type: {
          organizationId: ctx.organizationId,
          type: IntegrationType.GITHUB,
        },
      },
    })

    if (!githubIntegration || githubIntegration.status !== 'CONNECTED') {
      return {
        success: false,
        error: 'GitHub integration not connected',
        results: null,
      }
    }

    try {
      // Step 1: Analyze all GitHub repos
      const repoAnalyzer = new GitHubRepoAnalyzer(ctx.organizationId)
      const repoAnalyses = await repoAnalyzer.analyzeAllRepos()

      // Step 2: Run autonomous analyzer to generate tasks, bottlenecks, predictions
      const autonomousAnalyzer = new AutonomousAnalyzer(ctx.organizationId)
      const analysisResult = await autonomousAnalyzer.analyzeAndGenerate(repoAnalyses)

      // Step 3: Also run traditional bottleneck detection
      const bottleneckDetector = new BottleneckDetector(ctx.organizationId)
      await bottleneckDetector.runDetection()

      // Step 4: Run prediction engine
      const predictionEngine = new PredictionEngine({ organizationId: ctx.organizationId })
      await predictionEngine.runAllPredictions()

      // Run for each active project too
      const projects = await prisma.project.findMany({
        where: { organizationId: ctx.organizationId, status: 'ACTIVE' },
        select: { id: true },
      })

      for (const project of projects) {
        const projectEngine = new PredictionEngine({
          organizationId: ctx.organizationId,
          projectId: project.id,
        })
        await projectEngine.runAllPredictions()
      }

      return {
        success: true,
        error: null,
        results: {
          reposAnalyzed: repoAnalyses.length,
          ...analysisResult,
          repoSummaries: repoAnalyses.map(r => ({
            name: r.repo.fullName,
            completeness: r.completeness.score,
            openIssues: r.issues.open,
            openPRs: r.prs.open,
            todoCount: r.codeInsights.totalTodos,
          })),
        },
      }
    } catch (e) {
      console.error('Autonomous analysis failed:', e)
      return {
        success: false,
        error: String(e),
        results: null,
      }
    }
  }),

  // Get repo analysis without generating tasks (preview mode)
  getRepoAnalysis: managerProcedure.query(async ({ ctx }) => {
    const githubIntegration = await prisma.integration.findUnique({
      where: {
        organizationId_type: {
          organizationId: ctx.organizationId,
          type: IntegrationType.GITHUB,
        },
      },
    })

    if (!githubIntegration || githubIntegration.status !== 'CONNECTED') {
      return { connected: false, repos: [] }
    }

    try {
      const repoAnalyzer = new GitHubRepoAnalyzer(ctx.organizationId)
      const repoAnalyses = await repoAnalyzer.analyzeAllRepos()

      return {
        connected: true,
        repos: repoAnalyses.map(r => ({
          name: r.repo.name,
          fullName: r.repo.fullName,
          description: r.repo.description,
          url: r.repo.url,
          language: r.repo.language,
          completeness: r.completeness,
          structure: r.structure,
          issues: r.issues,
          prs: r.prs,
          codeInsights: {
            todoCount: r.codeInsights.todos.length,
            fixmeCount: r.codeInsights.fixmes.length,
            hackCount: r.codeInsights.hacks.length,
          },
        })),
      }
    } catch (e) {
      console.error('Repo analysis failed:', e)
      return { connected: true, repos: [], error: String(e) }
    }
  }),

  // Quick analysis stats
  getAnalysisStats: protectedProcedure.query(async ({ ctx }) => {
    const [
      totalTasks,
      autoGeneratedTasks,
      activeBottlenecks,
      activePredictions,
      totalProjects,
    ] = await Promise.all([
      prisma.task.count({ where: { organizationId: ctx.organizationId } }),
      prisma.task.count({
        where: {
          organizationId: ctx.organizationId,
          labels: { has: 'auto-generated' },
        },
      }),
      prisma.bottleneck.count({
        where: { project: { organizationId: ctx.organizationId }, status: 'ACTIVE' },
      }),
      prisma.prediction.count({
        where: { project: { organizationId: ctx.organizationId }, isActive: true },
      }),
      prisma.project.count({ where: { organizationId: ctx.organizationId } }),
    ])

    return {
      totalTasks,
      autoGeneratedTasks,
      activeBottlenecks,
      activePredictions,
      totalProjects,
    }
  }),

  // Force refresh all predictions and bottlenecks
  refreshInsights: protectedProcedure.mutation(async ({ ctx }) => {
    try {
      // Clear old predictions
      await prisma.prediction.updateMany({
        where: { project: { organizationId: ctx.organizationId } },
        data: { isActive: false },
      })

      // Run bottleneck detection
      const detector = new BottleneckDetector(ctx.organizationId)
      await detector.runDetection()

      // Run predictions
      const engine = new PredictionEngine({ organizationId: ctx.organizationId })
      await engine.runAllPredictions()

      // Run for projects
      const projects = await prisma.project.findMany({
        where: { organizationId: ctx.organizationId, status: 'ACTIVE' },
        select: { id: true },
      })

      for (const project of projects) {
        const projectEngine = new PredictionEngine({
          organizationId: ctx.organizationId,
          projectId: project.id,
        })
        await projectEngine.runAllPredictions()
      }

      const [bottlenecks, predictions] = await Promise.all([
        prisma.bottleneck.count({
          where: { project: { organizationId: ctx.organizationId }, status: 'ACTIVE' },
        }),
        prisma.prediction.count({
          where: { project: { organizationId: ctx.organizationId }, isActive: true },
        }),
      ])

      return {
        success: true,
        bottlenecksDetected: bottlenecks,
        predictionsGenerated: predictions,
      }
    } catch (e) {
      console.error('Refresh insights failed:', e)
      return { success: false, error: String(e) }
    }
  }),
})

export type AnalysisRouter = typeof analysisRouter
